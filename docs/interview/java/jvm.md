## JVM基础

**JVM简介**  
JVM（Java虚拟机）一种用于计算设备的规范，可用不同的方式（软件或硬件）加以实现。编译虚拟机的指令集与编译微处理器的指令集非常类似。JVM包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。JVM(Java虚拟机)是可运行Java代码的假想计算机。只要根据JVM规格描述将解释器移植到特定的计算机上，就能保证经过编译的任何Java代码能够在该系统上运行。JVM是一个想象中的机器，在实际的计算机上通过软件模拟来实现。JVM有自己想象中的硬件，如处理器、堆栈、寄存器等，还具有相应的指令系统。

**JVM特点**  
Java语言的一个非常重要的特点就是与平台的无关性。而使用JVM是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式JVM屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在JVM上运行的目标代码(字节码)，就可以在多种平台上不加修改地运行。JVM在执行字节码时，把字节码解释成具体平台上的机器指令执行。

**数据类型**  
Java虚拟机中，数据类型可以分为两类：基本类型和引用类型。基本类型的变量保存原始值，即：他代表的值就是数值本身；而引用类型的变量保存引用值。“引用值”代表了某个对象的引用，而不是对象本身，对象本身存放在这个引用值所表示的地址的位置。

基本类型包括：byte、short、int、long、char、float、double、Boolean、returnAddress  
引用类型包括：类类型、接口类型、数组

**堆和栈**
- 堆中存的是对象，栈中存的是基本数据类型和堆中对象的引用。
- 栈是运行时的单位，而堆是存储的单位。
- 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。
- 从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。
- 堆与栈的分离，使得堆中的内容可以被多个栈共
享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。

**参数传递**  
程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题，不会直接传对象本身。

**Java对象的大小**  
在Java中，一个空Object对象的大小是8byte，这个大小只是保存堆中一个没有任何属性的对象的大小。这样在程序中完成了一个Java对象的生命，但是它所占的空间为：4byte + 8byte。
- 4byte，是上面部分所说的Java栈中保存引用的所需要的空间。
- 8byte，是Java堆中对象的信息。因为所有的Java非基本类型的对象都需要默认继承Object对象，因此不论什么样的Java对象，其大小都必须是大于8byte。

基本类型的包装类型的大小至少是12byte（声明一个空Object至少需要的空间），而且12byte没有包含任何有效信息，同时，因为Java对象大小是8的整数倍，因此一个基本类型包装类的大小至少是16byte。

**引用类型**
- 强引用，就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收
- 软引用，软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生OutOfMemory时，肯定是没有软引用存在的。
- 弱引用，弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。
- 虚引用，顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在 任何时候都可能被垃圾回收

## 类加载机制
**类的生命周期**  
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：
- 加载
  获取类的二进制流，将静态存储结构转化为方法区的运行时数据结构，生产一个Class对象，作为方法区和类的数据入口。加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。
- 连接
  - 验证， 连接阶段的第一步，这一阶段的目的是为了确保Class文件中的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
  - 准备， 准备阶段是正式为类变量（被static修饰的变量）分配内存并设置类变量初始值（0值）的阶段，这些变量所使用的内存都将在方法区中进行分配。方法区中分配的是静态变量的内存，并为其设置0值，具体的值将在初始化阶段后再赋值。成员变量（实例变量）随对象一起在java堆中分配内存，具体的值也是在初始化阶段后再赋值。但是如果静态变量被 final 修饰，那么该静态变量在准备阶段就会被赋实际的值。
  - 解析， 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
- 初始化， 初始化阶段是类加载过程的最后一步，在此之前的阶段，基本都是由迅疾主导和控制。初始化的顺序是父类的静态变量，静态代码块，构造方法，再到子类。
- 使用
- 卸载

其中，验证、准备和解析三个部分称为连接。解析和初始化的相对顺序不是固定的，当解析在初始化之后执行时，称为动态绑定或者晚期绑定，例如：晚期绑定的多态特性。

**初始化**
- 遇到 new、get static、put static或invoke static 这4条指令时  
　如果类没有进行过初始化，则需要先触发其初始化。getstatic指读取一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）；invokestatic指调用一个类的静态方法。
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候  
　如果类没有进行过初始化，则需要先触发其初始化。
- 派生类  
　初始化一个派生类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类
　上述三种情况，被称为对一个类进行 主动引用。除此之外的引用类被称为 被动引用，不会触发初始化。
- 通过子类引用父类的静态字段，父类初始化，但子类不会初始化

## 内存管理
**内存区域**
- 程序计数寄存器  
  记载着每一个线程当前运行的JAVA方法的地址，如果是当前执行的是本地方法，则程序计数器会是一个空地址。它的作用就是用来支持多线程，线程的阻塞、恢复、挂起等一系列操作，直观的想象一下，要是没有记住每个线程当前运行的位置，又如何恢复呢。不会发生OutOfMemoryError的区域。
- Java虚拟机栈  
  JAVA虚拟机栈是在创建线程的同时创建的，用于存储栈帧，JAVA虚拟机栈也是线程独有的。  
  - 栈帧：简单点说，可以解释为是一个方法运行时，临时数据的存储区域，具体点说，它里面包括了数据和部分的过程结果，与此同时，它又肩负着处理方法返回值、动态链接以及异常分派的任务。栈帧是随着方法的创建而创建，随着方法的结束而销毁，如果方法抛出异常，也算方法结束。然而在每一个栈帧中，都有着自己的局部变量表以及操作数栈以及对当前类的运行时常量池的引用。
  - 局部变量表：它是一个方法局部变量的列表，是在编译时期就写入了class文件当中。简单的理解，可以将它理解为一个对象数组，而里面按照索引0到length-1分别对应于每一个局部变量，特别的，如果是实例方法的局部变量表，第0个局部变量会是一个指向当前实例的引用，也就是this关键字，其余的局部变量则从索引1开始。
  - 操作数栈：它是一个后进先出（LIFO）栈，而它的长度也是在编译时期就写入了class文件当中，是固定的。它的作用就是提供字节码指令操作变量计算的空间，比如简单的，对于int a=9这句话来说，就需要先将9压入操作数栈，再将9赋给a这个变量。
- 本地方法栈（线程独有）  
  本地方法栈是一个传统的栈，它用来支持native方法的执行。如果JAVA虚拟机是使用的其它语言实现指令集解释器的时候，也会用到本地方法栈。本地方法栈也是随每一个线程的启动而创建的。
- JAVA堆（全局共享）  
  它随着JAVA虚拟机的启动创建，储存着所有对象实例以及数组对象，而且内置了“自动内存管理系统”，也就是我们常说的垃圾搜集器（GC）。
- 方法区（全局共享）  
  方法区也是堆的一个组成部分，它主要存储的是运行时常量池、字段信息、方法信息、构造方法与普通函数的字节码内容以及一些特殊方法。它与JAVA堆的区别除了存储的信息与JAVA堆不一样之外，最大的区别就是这一部分JAVA虚拟机规范不强制要求实现自动内存管理系统（GC）。

**内存管理**  
 内存管理分为内存分配和内存释放，看一下上面的五个内存区域，其实可以大致分为两部分，一部分是全局共享，一部分是线程独有。
- 线程独有  
  对于线程独有的这部分内存，都是随着线程的启动而创建，而当线程被销毁时，内存也就随之释放。这一部分内存，不需要垃圾搜集器的管理，而是JAVA虚拟机来主动管理，每当一个线程被创建的时候，JAVA虚拟机就会为其分配相应的PC寄存器和JAVA虚拟机栈，如果需要的话，还会有本地方法栈。相应的，当一个线程被销毁的时候，JAVA虚拟机也会将这个线程所占有的内存全部释放。
- 全局共享  
  内存分配主要是由程序员显示的使用new关键字来触发的，至于new出来的这部分内存在哪分配，如何分配，则是JAVA虚拟机来决定。而这部分内存的释放，则是由自动内存管理系统（以下简称GC）来管理的。
  通常情况下，堆内存分配是要依赖于GC的策略与实现的，在分配的时候，就要考虑好到时候如何回收这部分内存。也是正因为如此，对于内存分配这一部分的讲解来说，我们必须得先了解内存是如何被回收的，才能更好的理解内存要怎么被分配。

## 垃圾回收机制
- 标记-清除算法  
  先标记出需要被回收的对象，然后全部清除。这种算法有两个严重的问题，一是标记清楚的效率不高，二是产生内存碎片。
- 复制算法  
  将内存划分为相等的两块区域A和B，一次只用其中一块A，当需要垃圾回收时，将A中所有存活的对象复制到B，然后清楚A，使用B。就这样周而复始。但是也有一个明显的问题：可使用的内存大小只有一半。
- 标记整理算法  
  先标记，然后让所有存活对象向另一端移动，然后直接清理端边界以外的内存
- 分代收集法  
  - 新生代  
    所有新对象创建发生在Eden区，Eden区满后触发新生代上的minor GC，将Eden区和非空闲Survivor区存活对象复制到另一个空闲的Survivor区中。
    永远保证一个Survivor是空的，新生代minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。
    由于新生代大多数对象是“朝生夕死”的所以，对于新生代采用有两个很小的Survivor区、一个大的Eden区，使用复制算法的原理进行回收：一次使用一个Survivor区1和Eden区，生还的对象移入另一个保留区2，然后清空所有，周而复始。
  - 老年代  
    Eden区满后触发minor GC将存活对象复制到Survivor区，Survivor区满后触发minor GC将存活对象复制到老年代。
    经过新生代的两个Survivor之间多次复制，仍然存活下来的对象就是年龄相对比较老的，就可以放入到老年代了，随着时间推移，如果老年代也满了，将触发Full GC，针对整个堆（包括新生代、老年代）进行垃圾回收。
    老年代大多数对象会长期存活，不适合复制算法，所以使用标记-整理算法。

## 参考
- http://blog.csdn.net/zzwwws/article/details/9150143
- https://juejin.im/post/58e5e9360ce4630058492fd5
- http://blog.csdn.net/wind5shy/article/details/8349559
- https://zhuanlan.zhihu.com/p/26386634
